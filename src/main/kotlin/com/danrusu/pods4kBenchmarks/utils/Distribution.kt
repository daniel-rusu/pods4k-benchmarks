package com.danrusu.pods4kBenchmarks.utils

import kotlin.random.Random

/**
 * Represents a probability distribution defined by 1 or more pairs.  Each pair defines the probability of that pair
 * being chosen along with the bounds for that pair, controlling the range of values that this pair can generate.
 *
 * For example, the following distribution results in
 * - For 80% of the time, a value will be generated in the closed range [0, 10]
 * - For 20% of the time, a value will be generated in the closed range [100, 120]
 *
 * Distribution(
 *     80 to Bounds(0, 10)
 *     20 to Bounds(100, 120)
 * )
 */
class Distribution(private val random: Random, vararg percentages: Pair<Int, Bounds>) {
    private val accumulatedPercentages: IntArray
    private val boundaries = Array(percentages.size) { percentages[it].second }

    /**
     * Represents the mathematical average value that this distribution will produce.
     *
     * Note that this average value itself might never be generated by this distribution when the distribution contains
     * gaps between the bounds.
     *
     * For example, a distribution could be specified to generate
     * - values between 0 and 10 for 50% of the time
     * - and values between 100 and 120 the other 50%
     *
     * but the average value is 26 which is not in any of the bounding intervals.
     */
    val averageValue: Double

    init {
        var accumulatedPercentage = 0
        var accumulatedValue = 0.0
        accumulatedPercentages = IntArray(percentages.size)

        for (index in percentages.indices) {
            val (percentage, bounds) = percentages[index]
            require(percentage > 0) { "The percentage ($percentage) must be positive" }

            accumulatedValue += percentage * bounds.computeAverageValue() / 100
            accumulatedPercentage += percentage
            accumulatedPercentages[index] = accumulatedPercentage
        }
        require(accumulatedPercentage == 100) {
            "The percentages must add up to 100 (found $accumulatedPercentage)"
        }

        averageValue = accumulatedValue
    }

    fun nextValue(): Int {
        val selector = random.nextInt(100)
        // note that a binary search would perform worse here as most distributions have a small number of boundaries.
        val index = accumulatedPercentages.indexOfFirst { selector < it }
        val bounds = boundaries[index]
        return random.nextInt(from = bounds.lowerBound, until = bounds.upperBound + 1)
    }

    /**
     * Defines the boundaries (both inclusive) of allowed values.
     */
    class Bounds(val lowerBound: Int, val upperBound: Int) {
        init {
            require(lowerBound <= upperBound) {
                "lowerBound ($lowerBound) cannot be greater than the upperBound ($upperBound)"
            }
        }

        fun computeAverageValue(): Double {
            return (lowerBound.toDouble() + upperBound.toDouble()) / 2.0
        }
    }
}

interface DistributionFactory {

    fun create(random: Random): Distribution

    /** Represents the size distribution of flat lists */
    object ListSizeDistribution : DistributionFactory {
        override fun create(random: Random): Distribution = Distribution(
            createNewRandomGenerator(from = random),
            35 to Distribution.Bounds(lowerBound = 0, upperBound = 10),
            30 to Distribution.Bounds(lowerBound = 11, upperBound = 50),
            20 to Distribution.Bounds(lowerBound = 51, upperBound = 200),
            10 to Distribution.Bounds(lowerBound = 201, upperBound = 1_000),
            5 to Distribution.Bounds(lowerBound = 1_001, upperBound = 10_000),
        )
    }

    /**
     * Represents the size distribution of nested lists.  This isn't the same as top-level flat lists as dealing
     * with multiple larger lists is typically dealt with in a streaming manner by operating on one list at a time
     * whereas nested lists are only stored in groups when they're expected to be smaller.
     *
     * Example scenarios of nested lists
     * - List of orders with each order containing a nested list of products.  Most orders contain just 1 or 2
     * different products (not to be confused with the quantity of a particular product).
     *
     * - List of people with each person containing a nested list of siblings.
     *
     * - List of cities with each city containing a nested list of attractions.
     */
    object NESTED_LIST_SIZE_DISTRIBUTION : DistributionFactory {
        override fun create(random: Random): Distribution = Distribution(
            createNewRandomGenerator(from = random),
            30 to Distribution.Bounds(lowerBound = 0, upperBound = 1),
            35 to Distribution.Bounds(lowerBound = 2, upperBound = 3),
            25 to Distribution.Bounds(lowerBound = 4, upperBound = 7),
            7 to Distribution.Bounds(lowerBound = 8, upperBound = 15),
            3 to Distribution.Bounds(lowerBound = 16, upperBound = 25),
        )
    }
}

/**
 * IMPORTANT: Use a separate random generator for the collection size distribution so that different element types
 * always end up with the same sequence of collection sizes.  That's because different element types can use the random
 * generator more often which can affect the sequence of collection sizes.  For example, while a random boolean value
 * only uses the generator once, generating a random string requires appending a random character multiple times.
 *
 * Also, the original is used for generating the seed in order to have repeatable results which also don't follow the
 * same sequence as the original random generator.
 */
private fun createNewRandomGenerator(from: Random): Random = Random(seed = from.nextLong())
